'''
8월 26일 내용 이어서 이론 공부
========================================
이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 
큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운 방식 이라고 말한다.

반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 
작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 방식이라고 말한다.

피보나치 수열 문제를 아래에서 위로 올라가는 보텀업 방식으로 풀면 다음과 같다.

# 피보나치 수열 소스코드 (반복적)
d = [0] * 100 

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])

탑다운 방식은 '하향식'이라고도 하며, 보텀업 방식은 '상향식'이라고도 한다.
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.
보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부르며, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.
다이나믹 프로그래밍과 메모이제이션의 개념을 혼용해서 사용하는 경우도 있는데,
엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하므로,
다이나믹 프로그래밍과는 별도의 개념이다.
한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.

코딩 테스트에서의 다이나믹 프로그래밍 문제는 대체로 간단한 형태로 출제되므로, 이 책에서 다루는 문제 정도만 바르게 습득해도 코딩 테스트에서
다이나믹 프로그래밍 문제를 풀기에는 큰 어려움이 없을 것이다.

문제를 푸는 첫 번째 단계는 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이다.
 - 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래걸리면
   다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자
 
 - 일단 단순히 재귀 함수로 비효율적인 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면
   즉, 메모이제이션을 적용할 수 있으면 코드를 개선하는 방법도 좋은 아이디어다.

앞서 다루었던 피보나치 수열의 예제처럼 재귀 함수를 작성한 뒤에 나중에 메모이제이션 기법을 적용해 소스코드를 수정하는 것도 좋은 방법이다.
# 또한 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다.
# 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.
'''
#실전문제 <2> 1로 만들기
n = int(input())

# 정수 x의 범위가 1이상 30,000이하 라서 30000개의 DP 테이블을 만들었다.
d = [0]* 30001

for i in range(2, n+1):
    d[i] = d[i - 1] + 1
    if n % 2 == 0:
        d[i] = min(d[i], d[i//2] + 1)
    if n % 3 == 0:
        d[i] = min(d[i], d[i//3] + 1)
    if n % 5 == 0:
        d[i] = min(d[i], d[i//5] + 1)
    


print(d[n])
'''
문제를 풀어봤는데 접근은 비슷하게 했지만 그다음 진행을 어떻게 해야 할지 몰라 답안을 본 상태인데 
답안이 출력이 잘못되서 나온다.
아직 알고리즘을 잘 이해하지 못했다.
앞의 보텀업 진행은 잘 이해했는데 이건 좀 이해가 되지 않는다.
디버깅을 통해 수의 변화를 살펴봤는데도 잘 이해가 되지 않는다.
다시 앞의 내용을 보고 봐야겠다.
min을 왜 쓴지도 모르겠기 때문에 문제해설을 읽고 그래도 안되면 앞으로 다시 넘어가야겠다.

'''